/**
 * Mindwell
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient

import org.openapitools.client.models.AuthProfile
import org.openapitools.client.models.Calendar
import org.openapitools.client.models.Entry
import org.openapitools.client.models.Error
import org.openapitools.client.models.Feed
import org.openapitools.client.models.FriendList
import org.openapitools.client.models.ImageList
import org.openapitools.client.models.MeOnlinePut200Response
import org.openapitools.client.models.Profile
import org.openapitools.client.models.TagList

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class MeApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "/api/v1")
        }
    }

    /**
     * 
     * 
     * @param file 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meAvatarPut(file: java.io.File) : Unit {
        val localVarResponse = meAvatarPutWithHttpInfo(file = file)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param file 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun meAvatarPutWithHttpInfo(file: java.io.File) : ApiResponse<Unit?> {
        val localVariableConfig = meAvatarPutRequestConfig(file = file)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meAvatarPut
     *
     * @param file 
     * @return RequestConfig
     */
    fun meAvatarPutRequestConfig(file: java.io.File) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/me/avatar",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param start  (optional, default to 0)
     * @param end  (optional, default to 0)
     * @param limit  (optional, default to 1000)
     * @return Calendar
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meCalendarGet(start: kotlin.Long? = 0, end: kotlin.Long? = 0, limit: kotlin.Int? = 1000) : Calendar {
        val localVarResponse = meCalendarGetWithHttpInfo(start = start, end = end, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Calendar
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param start  (optional, default to 0)
     * @param end  (optional, default to 0)
     * @param limit  (optional, default to 1000)
     * @return ApiResponse<Calendar?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meCalendarGetWithHttpInfo(start: kotlin.Long?, end: kotlin.Long?, limit: kotlin.Int?) : ApiResponse<Calendar?> {
        val localVariableConfig = meCalendarGetRequestConfig(start = start, end = end, limit = limit)

        return request<Unit, Calendar>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meCalendarGet
     *
     * @param start  (optional, default to 0)
     * @param end  (optional, default to 0)
     * @param limit  (optional, default to 1000)
     * @return RequestConfig
     */
    fun meCalendarGetRequestConfig(start: kotlin.Long?, end: kotlin.Long?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/calendar",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param file 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meCoverPut(file: java.io.File) : Unit {
        val localVarResponse = meCoverPutWithHttpInfo(file = file)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param file 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun meCoverPutWithHttpInfo(file: java.io.File) : ApiResponse<Unit?> {
        val localVariableConfig = meCoverPutRequestConfig(file = file)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meCoverPut
     *
     * @param file 
     * @return RequestConfig
     */
    fun meCoverPutRequestConfig(file: java.io.File) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/me/cover",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @param query  (optional)
     * @return Feed
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meFavoritesGet(limit: kotlin.Int? = 30, after: kotlin.String? = null, before: kotlin.String? = null, query: kotlin.String? = null) : Feed {
        val localVarResponse = meFavoritesGetWithHttpInfo(limit = limit, after = after, before = before, query = query)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Feed
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @param query  (optional)
     * @return ApiResponse<Feed?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meFavoritesGetWithHttpInfo(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?, query: kotlin.String?) : ApiResponse<Feed?> {
        val localVariableConfig = meFavoritesGetRequestConfig(limit = limit, after = after, before = before, query = query)

        return request<Unit, Feed>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meFavoritesGet
     *
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @param query  (optional)
     * @return RequestConfig
     */
    fun meFavoritesGetRequestConfig(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?, query: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/favorites",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return FriendList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meFollowersGet(limit: kotlin.Int? = 30, after: kotlin.String? = null, before: kotlin.String? = null) : FriendList {
        val localVarResponse = meFollowersGetWithHttpInfo(limit = limit, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FriendList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return ApiResponse<FriendList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meFollowersGetWithHttpInfo(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<FriendList?> {
        val localVariableConfig = meFollowersGetRequestConfig(limit = limit, after = after, before = before)

        return request<Unit, FriendList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meFollowersGet
     *
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return RequestConfig
     */
    fun meFollowersGetRequestConfig(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/followers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return FriendList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meFollowingsGet(limit: kotlin.Int? = 30, after: kotlin.String? = null, before: kotlin.String? = null) : FriendList {
        val localVarResponse = meFollowingsGetWithHttpInfo(limit = limit, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FriendList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return ApiResponse<FriendList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meFollowingsGetWithHttpInfo(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<FriendList?> {
        val localVariableConfig = meFollowingsGetRequestConfig(limit = limit, after = after, before = before)

        return request<Unit, FriendList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meFollowingsGet
     *
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return RequestConfig
     */
    fun meFollowingsGetRequestConfig(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/followings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @return AuthProfile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meGet() : AuthProfile {
        val localVarResponse = meGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthProfile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @return ApiResponse<AuthProfile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meGetWithHttpInfo() : ApiResponse<AuthProfile?> {
        val localVariableConfig = meGetRequestConfig()

        return request<Unit, AuthProfile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meGet
     *
     * @return RequestConfig
     */
    fun meGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return FriendList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meHiddenGet(limit: kotlin.Int? = 30, after: kotlin.String? = null, before: kotlin.String? = null) : FriendList {
        val localVarResponse = meHiddenGetWithHttpInfo(limit = limit, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FriendList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return ApiResponse<FriendList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meHiddenGetWithHttpInfo(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<FriendList?> {
        val localVariableConfig = meHiddenGetRequestConfig(limit = limit, after = after, before = before)

        return request<Unit, FriendList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meHiddenGet
     *
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return RequestConfig
     */
    fun meHiddenGetRequestConfig(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/hidden",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return FriendList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meIgnoredGet(limit: kotlin.Int? = 30, after: kotlin.String? = null, before: kotlin.String? = null) : FriendList {
        val localVarResponse = meIgnoredGetWithHttpInfo(limit = limit, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FriendList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return ApiResponse<FriendList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meIgnoredGetWithHttpInfo(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<FriendList?> {
        val localVariableConfig = meIgnoredGetRequestConfig(limit = limit, after = after, before = before)

        return request<Unit, FriendList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meIgnoredGet
     *
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return RequestConfig
     */
    fun meIgnoredGetRequestConfig(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/ignored",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return ImageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meImagesGet(limit: kotlin.Int? = 30, after: kotlin.String? = null, before: kotlin.String? = null) : ImageList {
        val localVarResponse = meImagesGetWithHttpInfo(limit = limit, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ImageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return ApiResponse<ImageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meImagesGetWithHttpInfo(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<ImageList?> {
        val localVariableConfig = meImagesGetRequestConfig(limit = limit, after = after, before = before)

        return request<Unit, ImageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meImagesGet
     *
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return RequestConfig
     */
    fun meImagesGetRequestConfig(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/images",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return FriendList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meInvitedGet(limit: kotlin.Int? = 30, after: kotlin.String? = null, before: kotlin.String? = null) : FriendList {
        val localVarResponse = meInvitedGetWithHttpInfo(limit = limit, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FriendList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return ApiResponse<FriendList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meInvitedGetWithHttpInfo(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<FriendList?> {
        val localVariableConfig = meInvitedGetRequestConfig(limit = limit, after = after, before = before)

        return request<Unit, FriendList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meInvitedGet
     *
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return RequestConfig
     */
    fun meInvitedGetRequestConfig(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/invited",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @return MeOnlinePut200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meOnlinePut() : MeOnlinePut200Response {
        val localVarResponse = meOnlinePutWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MeOnlinePut200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @return ApiResponse<MeOnlinePut200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meOnlinePutWithHttpInfo() : ApiResponse<MeOnlinePut200Response?> {
        val localVariableConfig = meOnlinePutRequestConfig()

        return request<Unit, MeOnlinePut200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meOnlinePut
     *
     * @return RequestConfig
     */
    fun meOnlinePutRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/me/online",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter privacy
     */
     enum class Privacy_mePut(val value: kotlin.String) {
         @Json(name = "all") all("all"),
         @Json(name = "invited") invited("invited"),
         @Json(name = "followers") followers("followers"),
         @Json(name = "registered") registered("registered")
     }

    /**
     * enum for parameter gender
     */
     enum class Gender_mePut(val value: kotlin.String) {
         @Json(name = "male") male("male"),
         @Json(name = "female") female("female"),
         @Json(name = "not set") notSet("not set")
     }

    /**
     * 
     * 
     * @param showName 
     * @param privacy 
     * @param gender  (optional, default to not set)
     * @param isDaylog  (optional, default to false)
     * @param title  (optional)
     * @param birthday  (optional)
     * @param country  (optional)
     * @param city  (optional)
     * @param showInTops  (optional, default to false)
     * @return Profile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mePut(showName: kotlin.String, privacy: Privacy_mePut, gender: Gender_mePut? = not set, isDaylog: kotlin.Boolean? = false, title: kotlin.String? = null, birthday: kotlin.String? = null, country: kotlin.String? = null, city: kotlin.String? = null, showInTops: kotlin.Boolean? = false) : Profile {
        val localVarResponse = mePutWithHttpInfo(showName = showName, privacy = privacy, gender = gender, isDaylog = isDaylog, title = title, birthday = birthday, country = country, city = city, showInTops = showInTops)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Profile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param showName 
     * @param privacy 
     * @param gender  (optional, default to not set)
     * @param isDaylog  (optional, default to false)
     * @param title  (optional)
     * @param birthday  (optional)
     * @param country  (optional)
     * @param city  (optional)
     * @param showInTops  (optional, default to false)
     * @return ApiResponse<Profile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mePutWithHttpInfo(showName: kotlin.String, privacy: Privacy_mePut, gender: Gender_mePut?, isDaylog: kotlin.Boolean?, title: kotlin.String?, birthday: kotlin.String?, country: kotlin.String?, city: kotlin.String?, showInTops: kotlin.Boolean?) : ApiResponse<Profile?> {
        val localVariableConfig = mePutRequestConfig(showName = showName, privacy = privacy, gender = gender, isDaylog = isDaylog, title = title, birthday = birthday, country = country, city = city, showInTops = showInTops)

        return request<Map<String, PartConfig<*>>, Profile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mePut
     *
     * @param showName 
     * @param privacy 
     * @param gender  (optional, default to not set)
     * @param isDaylog  (optional, default to false)
     * @param title  (optional)
     * @param birthday  (optional)
     * @param country  (optional)
     * @param city  (optional)
     * @param showInTops  (optional, default to false)
     * @return RequestConfig
     */
    fun mePutRequestConfig(showName: kotlin.String, privacy: Privacy_mePut, gender: Gender_mePut?, isDaylog: kotlin.Boolean?, title: kotlin.String?, birthday: kotlin.String?, country: kotlin.String?, city: kotlin.String?, showInTops: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "showName" to PartConfig(body = showName, headers = mutableMapOf()),
            "gender" to PartConfig(body = gender.value, headers = mutableMapOf()),
            "isDaylog" to PartConfig(body = isDaylog, headers = mutableMapOf()),
            "privacy" to PartConfig(body = privacy.value, headers = mutableMapOf()),
            "title" to PartConfig(body = title, headers = mutableMapOf()),
            "birthday" to PartConfig(body = birthday, headers = mutableMapOf()),
            "country" to PartConfig(body = country, headers = mutableMapOf()),
            "city" to PartConfig(body = city, headers = mutableMapOf()),
            "showInTops" to PartConfig(body = showInTops, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return FriendList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meRequestedGet(limit: kotlin.Int? = 30, after: kotlin.String? = null, before: kotlin.String? = null) : FriendList {
        val localVarResponse = meRequestedGetWithHttpInfo(limit = limit, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FriendList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return ApiResponse<FriendList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meRequestedGetWithHttpInfo(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<FriendList?> {
        val localVariableConfig = meRequestedGetRequestConfig(limit = limit, after = after, before = before)

        return request<Unit, FriendList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meRequestedGet
     *
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @return RequestConfig
     */
    fun meRequestedGetRequestConfig(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/requested",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @return TagList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meTagsGet(limit: kotlin.Int? = 30) : TagList {
        val localVarResponse = meTagsGetWithHttpInfo(limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TagList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @return ApiResponse<TagList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meTagsGetWithHttpInfo(limit: kotlin.Int?) : ApiResponse<TagList?> {
        val localVariableConfig = meTagsGetRequestConfig(limit = limit)

        return request<Unit, TagList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meTagsGet
     *
     * @param limit  (optional, default to 30)
     * @return RequestConfig
     */
    fun meTagsGetRequestConfig(limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/tags",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sort
     */
     enum class Sort_meTlogGet(val value: kotlin.String) {
         @Json(name = "new") new("new"),
         @Json(name = "old") old("old"),
         @Json(name = "best") best("best")
     }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @param tag  (optional)
     * @param sort  (optional, default to new)
     * @param query  (optional)
     * @return Feed
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meTlogGet(limit: kotlin.Int? = 30, after: kotlin.String? = null, before: kotlin.String? = null, tag: kotlin.String? = null, sort: Sort_meTlogGet? = new, query: kotlin.String? = null) : Feed {
        val localVarResponse = meTlogGetWithHttpInfo(limit = limit, after = after, before = before, tag = tag, sort = sort, query = query)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Feed
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @param tag  (optional)
     * @param sort  (optional, default to new)
     * @param query  (optional)
     * @return ApiResponse<Feed?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meTlogGetWithHttpInfo(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?, tag: kotlin.String?, sort: Sort_meTlogGet?, query: kotlin.String?) : ApiResponse<Feed?> {
        val localVariableConfig = meTlogGetRequestConfig(limit = limit, after = after, before = before, tag = tag, sort = sort, query = query)

        return request<Unit, Feed>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meTlogGet
     *
     * @param limit  (optional, default to 30)
     * @param after  (optional)
     * @param before  (optional)
     * @param tag  (optional)
     * @param sort  (optional, default to new)
     * @param query  (optional)
     * @return RequestConfig
     */
    fun meTlogGetRequestConfig(limit: kotlin.Int?, after: kotlin.String?, before: kotlin.String?, tag: kotlin.String?, sort: Sort_meTlogGet?, query: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/me/tlog",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter privacy
     */
     enum class Privacy_meTlogPost(val value: kotlin.String) {
         @Json(name = "all") all("all"),
         @Json(name = "registered") registered("registered"),
         @Json(name = "invited") invited("invited"),
         @Json(name = "followers") followers("followers"),
         @Json(name = "some") some("some"),
         @Json(name = "me") me("me")
     }

    /**
     * 
     * 
     * @param content 
     * @param privacy 
     * @param title  (optional)
     * @param images  (optional)
     * @param tags  (optional)
     * @param visibleFor  (optional)
     * @param isCommentable  (optional, default to true)
     * @param isVotable  (optional, default to false)
     * @param inLive  (optional, default to false)
     * @return Entry
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun meTlogPost(content: kotlin.String, privacy: Privacy_meTlogPost, title: kotlin.String? = null, images: kotlin.collections.Set<kotlin.Long>? = null, tags: kotlin.collections.Set<kotlin.String>? = null, visibleFor: kotlin.collections.List<kotlin.Long>? = null, isCommentable: kotlin.Boolean? = true, isVotable: kotlin.Boolean? = false, inLive: kotlin.Boolean? = false) : Entry {
        val localVarResponse = meTlogPostWithHttpInfo(content = content, privacy = privacy, title = title, images = images, tags = tags, visibleFor = visibleFor, isCommentable = isCommentable, isVotable = isVotable, inLive = inLive)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Entry
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param content 
     * @param privacy 
     * @param title  (optional)
     * @param images  (optional)
     * @param tags  (optional)
     * @param visibleFor  (optional)
     * @param isCommentable  (optional, default to true)
     * @param isVotable  (optional, default to false)
     * @param inLive  (optional, default to false)
     * @return ApiResponse<Entry?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun meTlogPostWithHttpInfo(content: kotlin.String, privacy: Privacy_meTlogPost, title: kotlin.String?, images: kotlin.collections.Set<kotlin.Long>?, tags: kotlin.collections.Set<kotlin.String>?, visibleFor: kotlin.collections.List<kotlin.Long>?, isCommentable: kotlin.Boolean?, isVotable: kotlin.Boolean?, inLive: kotlin.Boolean?) : ApiResponse<Entry?> {
        val localVariableConfig = meTlogPostRequestConfig(content = content, privacy = privacy, title = title, images = images, tags = tags, visibleFor = visibleFor, isCommentable = isCommentable, isVotable = isVotable, inLive = inLive)

        return request<Map<String, PartConfig<*>>, Entry>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation meTlogPost
     *
     * @param content 
     * @param privacy 
     * @param title  (optional)
     * @param images  (optional)
     * @param tags  (optional)
     * @param visibleFor  (optional)
     * @param isCommentable  (optional, default to true)
     * @param isVotable  (optional, default to false)
     * @param inLive  (optional, default to false)
     * @return RequestConfig
     */
    fun meTlogPostRequestConfig(content: kotlin.String, privacy: Privacy_meTlogPost, title: kotlin.String?, images: kotlin.collections.Set<kotlin.Long>?, tags: kotlin.collections.Set<kotlin.String>?, visibleFor: kotlin.collections.List<kotlin.Long>?, isCommentable: kotlin.Boolean?, isVotable: kotlin.Boolean?, inLive: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "title" to PartConfig(body = title, headers = mutableMapOf()),
            "content" to PartConfig(body = content, headers = mutableMapOf()),
            "images" to PartConfig(body = images, headers = mutableMapOf()),
            "tags" to PartConfig(body = tags, headers = mutableMapOf()),
            "privacy" to PartConfig(body = privacy.value, headers = mutableMapOf()),
            "visibleFor" to PartConfig(body = visibleFor, headers = mutableMapOf()),
            "isCommentable" to PartConfig(body = isCommentable, headers = mutableMapOf()),
            "isVotable" to PartConfig(body = isVotable, headers = mutableMapOf()),
            "inLive" to PartConfig(body = inLive, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/me/tlog",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
